---
date: 2022-12-05
title: '2022년 12월 5일'
authors: [cmjeon]
tags: ['토비의스프링']
draft: true
---

> '토비의스프링'의 '3장 테스트'

## 3.6 스프링의 JdbcTemplate

스프링의 템플릿/콜백 기술을 살펴보자.

스프링이 제공하는 JDBC 코드용 기본 템플릿은 JdbcTemplate 이다.

UserDao 가 JdbcTemplate 을 받을 수 있도록 변경한다.

<!--truncate-->

```java title="UserDao.java"
public class UserDao {
    
    // ...
    
    // highlight-next-line
    private JdbcTemplate jdbcTemplate;
    
    public void setDataSource(DataSource dataSource) {
        // highlight-next-line
        this.jdbcTemplate = new JdbcTemplate(dataSource);
        this.dataSource = dataSource;
    }
    
    // ...
    
}
```

### 3.6.1 update()

deleteAll() 메소드를 변경한다.

makePreparedStatement() 를 createPreparedStatement() 메소드로 변경한다.

이는 둘다 템플릿으로부터 Connection 을 제공받아서 PreparedStatement 를 돌려준다.

```java
public void deleteAll() {
    this.jdbcTemplate.update(
        new PreparedStatementCreator() {
            public PreparedStatement createPreparedStatement(Connection con) throws SELException {
                return con.prepareStatement("delete fro users");
            }
        }
    );
}
```

JdbcTemplate 의 내장 콜백을 사용하는 update() 메소드로 변경하였다.

```java
public void deleteAll() {
    this.jdbcTemplate.update("delete from users");
}
```

add() 메소드의 콜백에서 수행하는 PreparedStatement 를 만들고, 파라미터를 바인딩하는 작업도 update() 메소드로 가능하다.

```java
public void add() {
    this.jdbcTemplate.update("insert into users(id, name, password) values(?, ?, ?)", 
            user.getId(), 
            user.getName(),
            user.getPassword()
    );
}
```

### 3.6.2 queryForInt()

getCount() 메소드에 JdbcTemplate 의 query() 메소드를 적용한다.

```java
public int getCount() {
    return this.jdbcTemplate.query(
            new PreparedStatementCreator() {
                public PreparedStatement createPreparedStatement(Connection con) throws SQLException {
                    return con.prepareStatement("select count(*) from users");
                }
            },
            new ResultSetExtractor<Integer>() {
                public Integer extractData(ResultSet rs) throws SQLException, DataAccessException {
                    rs.next();
                    return rs.getInt(1);
                }
            }
    );
}
```

2개의 콜백이 있어 혼란스럽다.

원래 getCount() 메소드에 있던 코드 중에서 변하는 부분만 콜백으로 만들어져서 제공된다고 생각하면 된다.

클라이언트 -> 템플릿 -> 콜백의 관계를 기억하자.

두 번째 콜백은 Generic 을 사용하였다.

이를 통해 query() 템플릿의 리턴 타입도 바뀌게 된다.

위 두 개의 콜백을 내장하고 있는 query() 템플릿을 JdbcTemplate 의 queryForInt() 로 변경할 수 있다.

```java
public int getCount () {
    return this.jdbcTemplate.queryForInt("select count(*) from users");
}
```

### 3.6.3 queryForObject()

get() 메소드에도 JdbcTemplate 을 적용해보자.

get() 메소드에는 바인딩이 필요한 치환자가 있다.

그리고 ResultSet 이 User 객체로 리턴되어야 한다.

```java
public User get(String id) {
    return this.jdbcTemplate.queryForObject(
            "select * from users where id = ?",
            new Object[] {id},
            new RowMapper<User>() {
                public User mapRow(ResultSet rs, int rowNum) throws SQLException {
                    User user = new User();
                    user.setId(rs.getString("id"));
                    user.setName(rs.getString("name"));
                    user.setPassword(rs.getString("password"));
                    return user;
                }
            }
    );
}
```

첫 번째 파라미터는 PreparedStatement 를 만들기 위한 SQL, 두 번째는 바인딩할 값이다.

queryForObject() 메소드 내부에서 이 두 파라미터를 사용하는 PreparedStatement 콜백이 만들어진다.

RowMapper 에서는 ResultSet 의 로우 내용을 User 오브젝트에 담아서 리턴한다.

만약 queryForObject() 메소드의 실행결과가 비어있다면 EmptyResultDataAccessException 예외를 던지도록 만들어져 있다. 

### 3.6.4 query()




### 3.6.5 재사용 가능한 콜백의 분리


